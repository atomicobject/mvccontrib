<#
/*

Note: This was ported to VB.NET by DJP

I have marked changed sections with the following comments to try and ease future edits and ports, etc:

### START_VBNET_PORT_CHANGED ###

(CHANGES)

### END_VBNET_PORT_CHANGED ###

T4MVC Version 2.6.31
Find latest version and documentation at http://mvccontrib.codeplex.com/wikipage?title=T4MVC
Discuss on StackOverflow or on the MVC forum (http://forums.asp.net/1146.aspx) 

T4MVC is part of the MvcContrib project (http://mvccontrib.codeplex.com)
Maintained by David Ebbo, with much feedback from the MVC community (thanks all!)
david.ebbo@microsoft.com
http://twitter.com/davidebbo
http://blogs.msdn.com/davidebb

Related blog posts: http://blogs.msdn.com/davidebb/archive/tags/T4MVC/default.aspx

Please use in accordance to the MvcContrib license (http://mvccontrib.codeplex.com/license)
*/
#>
<#@ template language="C#v3.5" debug="true" hostspecific="true" #>
<#@ output extension=".vb" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#PrepareDataToRender(this); #>
<#var manager = Manager.Create(Host, GenerationEnvironment); #>
<#manager.StartHeader(); 

// ### START_VBNET_PORT_CHANGED ###

#>


' <auto-generated />
' This file was generated by a T4 template.
' Don't change it directly as your change would get overwritten.  Instead, make changes
' to the .tt file (i.e. the T4 template) and save it to regenerate this file.

#Region " T4MVC "

Imports System
Imports System.Diagnostics
Imports System.CodeDom.Compiler
Imports System.Collections.Generic
Imports System.Runtime.CompilerServices
Imports System.Web
Imports System.Web.Hosting
Imports System.Web.Mvc
Imports System.Web.Mvc.Ajax
Imports System.Web.Mvc.Html
Imports System.Web.Routing
Imports <#=string.IsNullOrEmpty(RootNamespaceOfProject) ? "" : (RootNamespaceOfProject + ".")#><#=T4MVCNamespace #>
<#foreach (var referencedNamespace in ReferencedNamespaces) { #>
Imports <#=referencedNamespace #>
<#} #>
<#manager.EndBlock(); #>

<CompilerGenerated(), DebuggerNonUserCode()> _
Public Class <#=HelpersPrefix #> 
<#if (IncludeAreasToken) { #>
Public Class Areas {
<#} #>
<#foreach (var area in Areas.Where(a => !string.IsNullOrEmpty(a.Name))) { #>
    Shared ReadOnly s_<#=area.Name #>  As <#=area.Name #>Class = New <#=area.Name #>Class()
	<#
	#>
    Public Shared ReadOnly Property <#=EscapeID(area.Namespace) #> As <#=area.Name #>Class 
		Get
			Return s_<#=area.Name #>
		End Get
	End Property
<#} #>
<#if (IncludeAreasToken) { #>
End Class
<#} #>
<#foreach (var controller in DefaultArea.GetControllers()) { #>
    Public Shared [<#=controller.Name #>] As <#=controller.FullClassName #>  = New <#=controller.FullDerivedClassName #>()
<#} #>
End Class

Namespace <#=T4MVCNamespace #>
<#foreach (var area in Areas.Where(a => !string.IsNullOrEmpty(a.Name))) { #>
    <CompilerGenerated(), DebuggerNonUserCode()> _
    Public Class <#=area.Name #>Class 
        Public ReadOnly Name As String = "<#=ProcessAreaOrControllerName(area.Name) #>"
<#foreach (var controller in area.GetControllers()) { #>
        Public [<#=controller.Name #>] As <#=controller.FullClassName #> = New <#=controller.FullDerivedClassName #>()
<#} #>
    End Class
<#} #>
End Namespace

'Namespace System.Web.Mvc
    <CompilerGenerated(), DebuggerNonUserCode()> _
    Public Module T4Extensions
	
		<Extension()> _
        Public Function ActionLink(ByVal htmlHelper As HtmlHelper, ByVal linkText As String, ByVal result As ActionResult) As <#=HtmlStringType #>
            Return htmlHelper.RouteLink(linkText, result.GetRouteValueDictionary())
        End Function
		
		<Extension()> _
        Public Function ActionLink(ByVal htmlHelper As HtmlHelper, ByVal linkText As String, ByVal result As ActionResult, ByVal htmlAttributes As Object) As <#=HtmlStringType #>
            Return ActionLink(htmlHelper, linkText, result, New RouteValueDictionary(htmlAttributes))
        End Function

		<Extension()> _
        Public Function ActionLink(ByVal htmlHelper As HtmlHelper, ByVal linkText As String, ByVal result As ActionResult, ByVal htmlAttributes As IDictionary(Of String, Object)) As  <#=HtmlStringType #>
            Return htmlHelper.RouteLink(linkText, result.GetRouteValueDictionary(), htmlAttributes)
        End Function

		<Extension()> _
        Public Function BeginForm(ByVal htmlHelper As HtmlHelper, ByVal result As ActionResult, ByVal formMethod As FormMethod) As MvcForm
            Return htmlHelper.BeginForm(result, formMethod, Nothing)
        End Function

		<Extension()> _
        Public Function BeginForm(ByVal htmlHelper As HtmlHelper, ByVal result As ActionResult, ByVal formMethod As FormMethod, ByVal htmlAttributes As Object) As MvcForm
            Return BeginForm(htmlHelper, result, formMethod, new RouteValueDictionary(htmlAttributes))
        End Function

		<Extension()> _
        Public Function BeginForm(ByVal htmlHelper As HtmlHelper, ByVal result As ActionResult, ByVal formMethod As FormMethod, ByVal htmlAttributes As IDictionary(Of String, Object)) As MvcForm
            Dim callInfo = result.GetT4MVCResult()
            Return htmlHelper.BeginForm(callInfo.Action, callInfo.Controller, callInfo.RouteValueDictionary, formMethod, htmlAttributes)
        End Function

<#if (MvcVersion >= 2) {#>
		
		<Extension()> _
        Public Sub RenderAction(ByVal htmlHelper As HtmlHelper, ByVal result As ActionResult) 
            Dim callInfo = result.GetT4MVCResult()
            htmlHelper.RenderAction(callInfo.Action, callInfo.Controller, callInfo.RouteValueDictionary)
        End Sub

		<Extension()> _
        Public Function Action(ByVal htmlHelper As HtmlHelper, ByVal result As ActionResult) As MvcHtmlString
            Dim callInfo = result.GetT4MVCResult()
            Return htmlHelper.Action(callInfo.Action, callInfo.Controller, callInfo.RouteValueDictionary)
        End Function
<#} #>
      
		<Extension()> _
		Public Function Action(ByVal urlHelper As UrlHelper, ByVal result As ActionResult) As String
            Return urlHelper.RouteUrl(result.GetRouteValueDictionary())
        End Function

		<Extension()> _
        Public Function ActionAbsolute(ByVal urlHelper As UrlHelper, ByVal result As ActionResult) As String
            Return String.Format("{0}{1}",urlHelper.RequestContext.HttpContext.Request.Url.GetLeftPart(UriPartial.Authority), _
                urlHelper.RouteUrl(result.GetRouteValueDictionary()))
        End Function

		<Extension()> _
        Public Function ActionLink(ByVal ajaxHelper As AjaxHelper, ByVal linkText As String, ByVal result As ActionResult, ByVal ajaxOptions As AjaxOptions) As <#=HtmlStringType #>
            Return ajaxHelper.RouteLink(linkText, result.GetRouteValueDictionary(), ajaxOptions)
        End Function

		<Extension()> _
        Public Function ActionLink(ByVal ajaxHelper As AjaxHelper, ByVal linkText As String, ByVal result As ActionResult, ByVal ajaxOptions As AjaxOptions, ByVal htmlAttributes As Object) As <#=HtmlStringType #>
            Return ajaxHelper.RouteLink(linkText, result.GetRouteValueDictionary(), ajaxOptions, New RouteValueDictionary(htmlAttributes))
        End Function

		<Extension()> _
		Public Function ActionLink(ByVal ajaxHelper As AjaxHelper, ByVal linkText As String, ByVal result As ActionResult, ByVal ajaxOptions As AjaxOptions, ByVal htmlAttributes As IDictionary(Of String, Object)) As <#=HtmlStringType #>
            Return ajaxHelper.RouteLink(linkText, result.GetRouteValueDictionary(), ajaxOptions, htmlAttributes)
        End Function

		<Extension()> _
		Public Function MapRoute(ByVal routes As RouteCollection, ByVal name As String, ByVal url As String, ByVal result As ActionResult) As Route
			Return MapRoute(routes, name, url, result, Nothing)
		End Function

		<Extension()> _
		Public Function MapRoute(ByVal routes As RouteCollection, ByVal name As String, ByVal url As String, ByVal result As ActionResult, ByVal defaults As Object) As Route
			Return MapRoute(routes, name, url, result, defaults, Nothing, Nothing)
		End Function

		<Extension()> _
		Public Function MapRoute(ByVal routes As RouteCollection, ByVal name As String, ByVal url As String, ByVal result As ActionResult, ByVal namespaces As String()) As Route
			Return MapRoute(routes, name, url, result, Nothing, namespaces)
		End Function

		<Extension()> _
		Public Function MapRoute(ByVal routes As RouteCollection, ByVal name As String, ByVal url As String, ByVal result As ActionResult, ByVal defaults As Object, ByVal constraints As Object) As Route
			Return MapRoute(routes, name, url, result, defaults, constraints, Nothing)
		End Function

		<Extension()> _
		Public Function MapRoute(ByVal routes As RouteCollection, ByVal name As String, ByVal url As String, ByVal result As ActionResult, ByVal defaults As Object, ByVal namespaces As String()) As Route
			Return MapRoute(routes, name, url, result, defaults, Nothing, namespaces)
		End Function

		<Extension()> _
		Public Function MapRoute(ByVal routes As RouteCollection, ByVal name As String, ByVal url As String, ByVal result As ActionResult, ByVal defaults As Object, ByVal constraints As Object, ByVal namespaces As String()) As Route
			' Create and add the route
			Dim route = CreateRoute(url, result, defaults, constraints, namespaces)
			routes.Add(name, route)
			Return route
		End Function

<#if (MvcVersion >= 2) {#>

		' Note: can't name the AreaRegistrationContext methods 'MapRoute', as that conflicts with the existing methods
		<Extension()> _
		Public Function MapRouteArea(ByVal context As AreaRegistrationContext, ByVal name As String, ByVal url As String, ByVal result As ActionResult) As Route
			Return MapRouteArea(context, name, url, result, Nothing)
		End Function

		<Extension()> _
		Public Function MapRouteArea(ByVal context As AreaRegistrationContext, ByVal name As String, ByVal url As String, ByVal result As ActionResult, ByVal defaults As Object) As Route
			Return MapRouteArea(context, name, url, result, defaults, Nothing, Nothing)
		End Function

		<Extension()> _
		Public Function MapRouteArea(ByVal context As AreaRegistrationContext, ByVal name As String, ByVal url As String, ByVal result As ActionResult, ByVal namespaces As String()) As Route
			Return MapRouteArea(context, name, url, result, Nothing, namespaces)
		End Function

		<Extension()> _
		Public Function MapRouteArea(ByVal context As AreaRegistrationContext, ByVal name As String, ByVal url As String, ByVal result As ActionResult, ByVal defaults As Object, ByVal constraints As Object) As Route
			Return MapRouteArea(context, name, url, result, defaults, constraints, Nothing)
		End Function

		<Extension()> _
		Public Function MapRouteArea(ByVal context As AreaRegistrationContext, ByVal name As String, ByVal url As String, ByVal result As ActionResult, ByVal defaults As Object, ByVal namespaces As String()) As Route
			Return MapRouteArea(context, name, url, result, defaults, Nothing, namespaces)
		End Function

		<Extension()> _
		Public Function MapRouteArea(ByVal context As AreaRegistrationContext, ByVal name As String, ByVal url As String, ByVal result As ActionResult, ByVal defaults As Object, ByVal constraints As Object, ByVal namespaces As String()) As Route
			' Create and add the route
			Dim route = CreateRoute(url, result, defaults, constraints, namespaces)
			context.Routes.Add(name, route)
			route.DataTokens("area") = context.AreaName
			Return route
		End Function

<#} #>

		Private Function CreateRoute(ByVal url As String, ByVal result As ActionResult, ByVal defaults As Object, ByVal constraints As Object, ByVal namespaces As String()) As Route
			' Start by adding the default values from the anonymous object (if any)
			Dim routeValues = New RouteValueDictionary(defaults)

			' Then add the Controller/Action names and the parameters from the call
			For Each pair In result.GetRouteValueDictionary()
				routeValues.Add(pair.Key, pair.Value)
			Next

			Dim routeConstraints = New RouteValueDictionary(constraints)

			' Create and add the route
			Dim route = New Route(url, routeValues, routeConstraints, New MvcRouteHandler())

			route.DataTokens = New RouteValueDictionary()

			If namespaces IsNot Nothing AndAlso namespaces.Length > 0 Then
				route.DataTokens("Namespaces") = namespaces
			End If

			Return route
		End Function


		<Extension()> _
        Public Function GetT4MVCResult(ByVal result As ActionResult) As <#=ActionResultInterfaceName #>
            Dim t4MVCResult = TryCast(result, <#=ActionResultInterfaceName #>)
            If (t4MVCResult Is Nothing) Then
                Throw New InvalidOperationException("T4MVC methods can only be passed pseudo-action calls (e.g. MVC.Home.About()), and not real action calls.")
            End If
            Return t4MVCResult
        End Function
		

		<Extension()> _
		Public Function GetRouteValueDictionary(ByVal result As ActionResult) As RouteValueDictionary
            Return result.GetT4MVCResult().RouteValueDictionary
        End Function

		<Extension()> _
		Public Function AddRouteValues(ByVal result As ActionResult, ByVal routeValues As Object) As ActionResult
            Return result.AddRouteValues(new RouteValueDictionary(routeValues))
        End Function

		<Extension()> _
		Public Function AddRouteValues(ByVal result As ActionResult, ByVal routeValues As RouteValueDictionary) As ActionResult
            Dim currentRouteValues = result.GetRouteValueDictionary()

            'Add all the extra values
            For Each pair In routeValues 
                currentRouteValues.Add(pair.Key, pair.Value)
            Next 'pair

            Return result
        End Function

		<Extension()> _
        Public Function AddRouteValues(ByVal result As ActionResult, ByVal nameValueCollection As System.Collections.Specialized.NameValueCollection) As ActionResult
            'Copy all the values from the NameValueCollection into the route dictionary
            nameValueCollection.CopyTo(result.GetRouteValueDictionary())
            Return result
        End Function

		<Extension()> _
        Public Function AddRouteValue(ByVal result As ActionResult, ByVal name As String, ByVal value As Object) As ActionResult
            Dim routeValues = result.GetRouteValueDictionary()
            routeValues.Add(name, value)
            Return result
        End Function

		<Extension()> _	
        Public Sub InitMVCT4Result(ByVal result As <#=ActionResultInterfaceName #>, ByVal area As String, ByVal controller As String, ByVal action As String)
            result.Controller = controller
            result.Action = action
            result.RouteValueDictionary = new RouteValueDictionary()
            <# if (Areas.Count > 1) { #>result.RouteValueDictionary.Add("Area", If(area Is Nothing,"",area))<# } #> 
            result.RouteValueDictionary.Add("Controller", controller)
            result.RouteValueDictionary.Add("Action", action)
        End Sub

        Public Function FileExists(ByVal virtualPath As String) As Boolean
            If (Not HostingEnvironment.IsHosted) Then 
				Return False
			End If
            Dim filePath = HostingEnvironment.MapPath(virtualPath)
            Return System.IO.File.Exists(filePath)
        End Function

        Private CenturyBegin As New DateTime(2001, 1, 1)
        Public Function TimestampString(ByVal virtualPath As String) As String
            If (Not HostingEnvironment.IsHosted) Then 
				Return String.Empty
            End If
			Dim filePath = HostingEnvironment.MapPath(virtualPath)
            Return Convert.ToString((Convert.ToInt64((System.IO.File.GetLastWriteTimeUtc(filePath).Ticks - CenturyBegin.Ticks) / 1000000000)), 16)       
        End Function

End Module


<#if (GenerateActionResultInterface) { #>   
<CompilerGenerated()> _   
Public Interface <#=ActionResultInterfaceName #>   
    Property Action As String  
    Property Controller As String 
    Property RouteValueDictionary As RouteValueDictionary   
End Interface   
<#} #>  

<#foreach (var resultType in ResultTypes.Values) { #>
<CompilerGenerated(), DebuggerNonUserCode()> _
Public Class T4MVC_<#=resultType.Name #>
	Inherits <#=resultType.FullName #>
	Implements <#=ActionResultInterfaceName #>
    
	Public Sub New(ByVal area As String, ByVal controller As String, ByVal action As String)
        MyBase.New(<#resultType.Constructor.WriteNonEmptyParameterValues(true); #>)
		Me.InitMVCT4Result(area, controller, action)
    End Sub
    <#foreach (var method in resultType.AbstractMethods) { #> 
    <#=method.IsPublic ? "Public" : "Protected" #> Overrides Sub <#=method.Name #>(<#method.WriteFormalParameters(true); #>)
    End Sub
	<#} #>

    Private m_Controller As String
    Public Property Controller As String Implements IT4MVCActionResult.Controller
        Get
            Return m_Controller
        End Get
        Set(ByVal value As String)
            m_Controller = value
        End Set	
	End Property
	
    Private m_Action As String	
    Public Property Action As String Implements IT4MVCActionResult.Action
        Get
            Return m_Action
        End Get
        Set(ByVal value As String)
            m_Action = value
        End Set		
	End Property
	
	Private m_RouteValueDictionary As New RouteValueDictionary()
    Public Property RouteValueDictionary As RouteValueDictionary Implements IT4MVCActionResult.RouteValueDictionary
        Get
            Return m_RouteValueDictionary
        End Get
        Set(ByVal value As RouteValueDictionary)
            m_RouteValueDictionary = value
        End Set		
	End Property
	
End Class
<#} #>



Namespace <#=LinksNamespace #>
<#
foreach (string folder in StaticFilesFolders) {
    ProcessStaticFiles(Project, folder);
}
#>
End Namespace

<#
RenderAdditionalCode();
#>
<#foreach (var controller in GetAbstractControllers().Where(c => !c.HasDefaultConstructor)) { #>
<#manager.StartNewFile(controller.GeneratedFileName); #>
Namespace <#=controller.Namespace #> 
    Public Partial Class <#=controller.ClassName #> 
        Protected Sub New()
		End Sub
    End Class
End Namespace
<#manager.EndBlock(); #>
<#} #>

<#foreach (var controller in GetControllers()) { #>
<#
    // Don't generate the file at all if the existing one is up to date
	// NOTE: disable this optimization since it doesn't catch view changes! It can be re-enabled later if smarter change detection is added 	
    //if (controller.GeneratedCodeIsUpToDate) {
    //    manager.KeepGeneratedFile(controller.GeneratedFileName);
    //    continue;
    //}
#>
<#manager.StartNewFile(controller.GeneratedFileName); #>
<#if (!String.IsNullOrEmpty(controller.Namespace)) { #>
Namespace <#=controller.Namespace #>
<#} #>
    Public <#if (!controller.NotRealController) { #>Partial <#} #>Class <#=controller.ClassName #>
<#if (!controller.NotRealController) { #>
<#if (!controller.HasExplicitConstructor) { #>
        <CompilerGenerated(), DebuggerNonUserCode()> _
        Public Sub New()
		End Sub

<#} #>
        <CompilerGenerated(), DebuggerNonUserCode()> _
        Protected Sub New(ByVal d As Dummy)
		End Sub

        <CompilerGenerated(), DebuggerNonUserCode()> _
        Protected Overloads Function RedirectToAction(ByVal result As ActionResult) As RedirectToRouteResult
            Dim callInfo = result.GetT4MVCResult()
            Return RedirectToRoute(callInfo.RouteValueDictionary)
        End Function

<#foreach (var method in controller.ActionMethodsUniqueWithoutParameterlessOverload) { #>
        <NonAction()> _
        <CompilerGenerated(), DebuggerNonUserCode()> _
        Public Function <#=method.Name #>() As <#=method.ReturnTypeFullName #>
            Return New T4MVC_<#=method.ReturnType #>(Area, Name, ActionNames.<#=method.ActionName #>)
        End Function
<#} #>

        <CompilerGenerated(), DebuggerNonUserCode()> _
		Public ReadOnly Property Actions As <#=controller.ClassName #>
			Get
				Return <#=controller.T4MVCControllerFullName #>
			End Get
		End Property
		
		
        <CompilerGenerated()> _
        Public ReadOnly Area As String = "<#=ProcessAreaOrControllerName(controller.AreaName) #>"
        <CompilerGenerated()> _
        Public ReadOnly Name As String = "<#=ProcessAreaOrControllerName(controller.Name) #>"

        Shared ReadOnly s_actions As ActionNamesClass = New ActionNamesClass()
        <CompilerGenerated(), DebuggerNonUserCode()> _
        Public ReadOnly Property ActionNames As ActionNamesClass
			Get
				Return s_actions
			End Get
		End Property
		
        <CompilerGenerated(), DebuggerNonUserCode()> _
        Public Class ActionNamesClass 
<#foreach (var method in controller.ActionMethodsWithUniqueNames) { #>
<#  if (UseLowercaseRoutes) { #>
            Public ReadOnly [<#=method.ActionName #>] As String = (<#=method.ActionNameValueExpression #>).ToLowerInvariant()
<#  } else { #>
            Public ReadOnly [<#=method.ActionName #>] As String = <#=method.ActionNameValueExpression #>
<#  }
} #>
        End Class

<#} #>


        Shared ReadOnly s_views As ViewNames = New ViewNames()
        <CompilerGenerated(), DebuggerNonUserCode()> _
        Public ReadOnly Property Views As ViewNames 
			Get
				Return s_views
			End Get
        End Property
		
		<CompilerGenerated(), DebuggerNonUserCode()> _
        Public Class ViewNames
<#RenderControllerViews(controller);#>
        End Class
    
	End Class

<#if (!controller.NotRealController) { #>
    <CompilerGenerated(), DebuggerNonUserCode()> _
    Public Class <#=controller.DerivedClassName #> 
		Inherits <#=controller.FullClassName #>
		
        Public Sub New() 
			MyBase.New(Dummy.Instance)
		End Sub

<#foreach (var method in controller.ActionMethods) { #>
        Public Overrides Function <#=method.Name #>(<#method.WriteFormalParameters(true); #>) As <#=method.ReturnTypeFullName #>
            Dim callInfo = new T4MVC_<#=method.ReturnType #>(Area, Name, ActionNames.<#=method.ActionName #>)
<#if (method.Parameters.Count > 0) { #>
<#foreach (var p in method.Parameters) { #>
            callInfo.RouteValueDictionary.Add(<#=p.RouteNameExpression #>, <#=p.Name #>)
<#} #>
<#}#>
            Return callInfo
        End Function

<#} #>
    End Class
<#} #>
<#if (!String.IsNullOrEmpty(controller.Namespace)) { #>
End Namespace
<#} #>

<#manager.EndBlock(); #>
<#} #>


'Namespace <#=T4MVCNamespace #> 
    <CompilerGenerated(), DebuggerNonUserCode()> _
    Public Class Dummy
        Private Sub New()
		End Sub
        Public Shared Instance As Dummy = New Dummy()
    End Class
'End Namespace

<# if (ExplicitHtmlHelpersForPartials) {
        manager.StartNewFile("T4MVC.ExplicitExtensions.vb"); #>    

'Namespace System.Web.Mvc        
   <CompilerGenerated(), DebuggerNonUserCode()> _
   Public Module HtmlHelpersForExplicitPartials
   <#  
	   foreach(var part in GetPartials()) {
           string partialName = part.Key;
           string partialPath = part.Value;
           string partialRenderMethod = string.Format(ExplicitHtmlHelpersForPartialsFormat, partialName);
   #>         
       '''<summary>
       '''Render the <b><#= partialName #></b> partial.
       '''</summary>
	   <Extension()> _	 
       Public Sub <#= partialRenderMethod #>(ByVal html As HtmlHelper) 
           html.RenderPartial("<#= partialPath #>")
       End Sub
       
       '''<summary>
       '''Render the <b><#= partialName #></b> partial.
       '''</summary> 
	   <Extension()> _
       Public Sub <#= partialRenderMethod #>(ByVal html As HtmlHelper, ByVal model As Object)
           html.RenderPartial("<#= partialPath #>", model)
       End Sub
   <# } #>     
   End Module
' End Namespace
<#    manager.EndBlock(); #>   
<#    }    #>   



<#manager.StartFooter(); #>
#End Region 'T4MVC
' #pragma warning restore 1591
<#manager.EndBlock(); #>
<#manager.Process(SplitIntoMultipleFiles); #>

<#@ Include File="T4MVCVB.settings.t4" #>

<#+ 
const string T4MVCNamespace = "T4MVC";
const string ControllerSuffix = "Controller";

static DTE Dte;
static Project Project;
static string AppRoot;
static HashSet<AreaInfo> Areas;
static AreaInfo DefaultArea;
static Dictionary<string, ResultTypeInfo> ResultTypes;
static TextTransformation TT;
static string T4FileName;
static string T4Folder;
static string GeneratedCode = @"GeneratedCode(""T4MVC"", ""2.0"")";
static float MvcVersion;
static string HtmlStringType;
static Microsoft.VisualBasic.VBCodeProvider codeProvider = new Microsoft.VisualBasic.VBCodeProvider();

IEnumerable<ControllerInfo> GetControllers() {
    var controllers = new List<ControllerInfo>();

    foreach (var area in Areas) {
        controllers.AddRange(area.GetControllers());
    }

    return controllers;
}

IEnumerable<ControllerInfo> GetAbstractControllers() {
    var controllers = new List<ControllerInfo>();

    foreach (var area in Areas) {
        controllers.AddRange(area.GetAbstractControllers());
    }

    return controllers;
}

IDictionary<string, string> GetPartials() {
	var parts = GetControllers()
		.Select(m => m.ViewsFolder)
		.SelectMany(m => m.Views)
		.Where(m => m.Value.EndsWith(".ascx"));
 
	var partsDic = new Dictionary<string, KeyValuePair<string, string>>();
 
	foreach(var part in parts) {
		//Check if we already have a partial view by that name (eg if two Views folders have the same ascx) 
		int keyCollisionCount = partsDic.Where(m => m.Key == part.Key || m.Value.Key == part.Key).Count();
 
		if (keyCollisionCount > 0) {
			// Append a numbered suffix to avoid the conflict 
			partsDic.Add(part.Key + keyCollisionCount.ToString(), part);
		}
		else {
			partsDic.Add(part.Key, part);
		}
	}
 
	return partsDic.ToDictionary(k => k.Key, v => v.Value.Value);
}

void PrepareDataToRender(TextTransformation tt) {
    TT = tt;
    T4FileName = Path.GetFileName(Host.TemplateFile);
    T4Folder = Path.GetDirectoryName(Host.TemplateFile);
    Areas = new HashSet<AreaInfo>();
    ResultTypes = new Dictionary<string, ResultTypeInfo>();

    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null) {
        Dte = serviceProvider.GetService(typeof(SDTE)) as DTE;
    }

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (Dte == null) {
        throw new Exception("T4MVC can only execute through the Visual Studio host");
    }

    Project = GetProjectContainingT4File(Dte);

    if (Project == null) {
        Error("Could not find the VS Project containing the T4 file.");
        return;
    }

    // Get the path of the root folder of the app
    AppRoot = Path.GetDirectoryName(Project.FullName) + '\\';

    MvcVersion = GetMvcVersion();

    // Use the proper return type of render helpers
    HtmlStringType = MvcVersion < 2 ? "string" : "MvcHtmlString";

    ProcessAreas(Project);
}

float GetMvcVersion() {
    var vsProject = (VSLangProj.VSProject)Project.Object;

    foreach (VSLangProj.Reference r in vsProject.References) {
        if (r.Name.Equals("System.Web.Mvc", StringComparison.OrdinalIgnoreCase)) {
            return r.MajorVersion + (r.MinorVersion / 10);
        }
    }

    // We should never get here, but default to v1 just in case
    return 1;
}

Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    if (AlwaysKeepTemplateDirty) {
        // Mark the .tt file as unsaved. This way it will be saved and update itself next time the
        // project is built. Basically, it keeps marking itself as unsaved to make the next build work.
        // Note: this is certainly hacky, but is the best I could come up with so far.
        projectItem.Document.Saved = false;
    }

    return projectItem.ContainingProject;
}

void ProcessAreas(Project project) {
    // Process the default area
    ProcessArea(project.ProjectItems, null);

    // Get the Areas folder
    ProjectItem areaProjectItem = GetProjectItem(project, AreasFolder);
    if (areaProjectItem == null)
        return;

    foreach (ProjectItem item in areaProjectItem.ProjectItems) {
        if (IsFolder(item)) {
            ProcessArea(item.ProjectItems, item.Name);
        }
    }
}

void ProcessArea(ProjectItems areaFolderItems, string name) {
    var area = new AreaInfo() { Name = name };
    ProcessAreaControllers(areaFolderItems, area);
    ProcessAreaViews(areaFolderItems, area);
    Areas.Add(area);

    if (String.IsNullOrEmpty(name))
        DefaultArea = area;
}

void ProcessAreaControllers(ProjectItems areaFolderItems, AreaInfo area) {
    // Get area Controllers folder
    ProjectItem controllerProjectItem = GetProjectItem(areaFolderItems, ControllersFolder);
    if (controllerProjectItem == null)
        return;

    ProcessControllersRecursive(controllerProjectItem, area);
}

void ProcessAreaViews(ProjectItems areaFolderItems, AreaInfo area) {
    // Get area Views folder
    ProjectItem viewsProjectItem = GetProjectItem(areaFolderItems, ViewsRootFolder);
    if (viewsProjectItem == null)
        return;

    ProcessAllViews(viewsProjectItem, area);
}

void ProcessControllersRecursive(ProjectItem projectItem, AreaInfo area) {

    // Recurse into all the sub-items (both files and folder can have some - e.g. .tt files)
    foreach (ProjectItem item in projectItem.ProjectItems) {
        ProcessControllersRecursive(item, area);
    }

    if (projectItem.FileCodeModel != null) {
        DateTime controllerLastWriteTime = File.GetLastWriteTime(projectItem.get_FileNames(0));
        foreach (var type in projectItem.FileCodeModel.CodeElements.OfType<CodeClass2>()) {
            ProcessControllerType(type, area, controllerLastWriteTime);
        }
        // Process all the elements that are namespaces
        foreach (var ns in projectItem.FileCodeModel.CodeElements.OfType<CodeNamespace>()) {
            foreach (var type in ns.Members.OfType<CodeClass2>()) {
                ProcessControllerType(type, area, controllerLastWriteTime);
            }
        }
    }
}

void ProcessControllerType(CodeClass2 type, AreaInfo area, DateTime controllerLastWriteTime) {
    // Only process types that end with Controller
    // REVIEW: this check is not super reliable. Should look at base class.
    if (!type.Name.EndsWith(ControllerSuffix, StringComparison.OrdinalIgnoreCase))
        return;

    // Don't process generic classes (their concrete derived classes will be processed)
    if (type.IsGeneric)
        return;

    // Make sure the class is partial
    if (type.ClassKind != vsCMClassKind.vsCMClassKindPartialClass) {
        try {
            type.ClassKind = vsCMClassKind.vsCMClassKindPartialClass;
        }
        catch {
            // If we couldn't make it partial, give a warning and skip it
            Warning(String.Format("{0} was not able to make the class {1} partial. Please change it manually if possible", T4FileName, type.Name));
            return;
        }
        Warning(String.Format("{0} changed the class {1} to be partial", T4FileName, type.Name));
    }

    // Collect misc info about the controller class and add it to the collection
    var controllerInfo = new ControllerInfo {
        Area = area,
        Namespace = type.Namespace != null ? type.Namespace.Name : String.Empty,
        ClassName = type.Name
    };

    // Check if the controller has changed since the generated file was last created
    DateTime lastGenerationTime = File.GetLastWriteTime(controllerInfo.GeneratedFileFullPath);
    if (lastGenerationTime > controllerLastWriteTime) {
        controllerInfo.GeneratedCodeIsUpToDate = true;
    }

    // Either process new ControllerInfo or integrate results into existing object for partially defined controllers
    var target = area.Controllers.Add(controllerInfo) ? controllerInfo : area.Controllers.First(c => c.Equals(controllerInfo));
    target.HasExplicitConstructor |= HasExplicitConstructor(type);
    target.HasExplicitDefaultConstructor |= HasExplicitDefaultConstructor(type);

    if (type.IsAbstract) {
        // If it's abstract, set a flag and don't process action methods (derived classes will)
        target.IsAbstract = true;
    }
    else {
        // Process all the action methods in the controller
        ProcessControllerActionMethods(target, type);
    }
}

void ProcessControllerActionMethods(ControllerInfo controllerInfo, CodeClass2 current) {

    // We want to process not just the controller class itself, but also its parents, as they
    // may themselves define actions
    for (CodeClass2 type = current; type != null && type.FullName != "System.Web.Mvc.Controller"; type = (CodeClass2)type.Bases.Item(1)) {

        // If the type doesn't come from this project, some actions on it will fail. Try to get a real project type if possible.
        if (type.InfoLocation != vsCMInfoLocation.vsCMInfoLocationProject) {
            // Go through all the projects in the solution
            //foreach (Project prj in Dte.Solution.Projects) {
            for (int i = 1; i <= Dte.Solution.Projects.Count; i++) {
                Project prj = null;
                try {
                    prj = Dte.Solution.Projects.Item(i);
                }
                catch (System.Runtime.Serialization.SerializationException) {
                    // Some project types (that we don't care about) cause a strange exception, so ingore it
                    continue;
                }

                // Skip it if it's the current project or doesn't have a code model
                if (prj == Project || prj.CodeModel == null)
                    continue;

                // If we can get a local project type, use it instead of the original
                var codeType = prj.CodeModel.CodeTypeFromFullName(type.FullName);
                if (codeType != null && codeType.InfoLocation == vsCMInfoLocation.vsCMInfoLocationProject) {
                    type = (CodeClass2)codeType;
                    break;
                }
            }
        }

        foreach (CodeFunction2 method in GetMethods(type)) {
            // Ignore non-public methods
            if (method.Access != vsCMAccess.vsCMAccessPublic)
                continue;

            // Ignore methods that are marked as not being actions
            if (GetAttribute(method.Attributes, "System.Web.Mvc.NonActionAttribute") != null)
                continue;

            // This takes care of avoiding generic types which cause method.Type.CodeType to blow up
            if (method.Type.TypeKind != vsCMTypeRef.vsCMTypeRefCodeType)
                continue;

            // We only support action methods that return an ActionResult derived type
            if (!method.Type.CodeType.get_IsDerivedFrom("System.Web.Mvc.ActionResult")) {
                Warning(String.Format("{0} doesn't support {1}.{2} because it doesn't return a supported ActionResult type", T4FileName, type.Name, method.Name));
                continue;
            }

            // If we haven't yet seen this return type, keep track of it
            if (!ResultTypes.ContainsKey(method.Type.CodeType.Name)) {
                var resTypeInfo = new ResultTypeInfo(method.Type.CodeType);

                ResultTypes[method.Type.CodeType.Name] = resTypeInfo;
            }

            // Make sure the method is virtual
            if (!method.CanOverride && method.OverrideKind != vsCMOverrideKind.vsCMOverrideKindOverride) {
                try {
                    method.CanOverride = true;
                }
                catch {
                    // If we couldn't make it virtual, give a warning and skip it
                    Warning(String.Format("{0} was not able to make the action method {1}.{2} virtual. Please change it manually if possible", T4FileName, type.Name, method.Name));
                    continue;
                }
                Warning(String.Format("{0} changed the action method {1}.{2} to be virtual", T4FileName, type.Name, method.Name));
            }

            // Collect misc info about the action method and add it to the collection
            controllerInfo.ActionMethods.Add(new ActionMethodInfo(method));
        }
    }
}

void ProcessAllViews(ProjectItem viewsProjectItem, AreaInfo area) {
    // Go through all the sub-folders in the Views folder
    foreach (ProjectItem item in viewsProjectItem.ProjectItems) {

        // We only care about sub-folders, not files
        if (!IsFolder(item))
            continue;

        // Find the controller for this view folder
        ControllerInfo controller = area.Controllers.SingleOrDefault(c => c.Name.Equals(item.Name, StringComparison.OrdinalIgnoreCase));

        if (controller == null) {
            // If it doesn't match a controller, treat as a pseudo-controller for consistency
            controller = new ControllerInfo {
                Area = area,
                NotRealController = true,
                Namespace = MakeClassName(T4MVCNamespace, area.Name),
                ClassName = item.Name + ControllerSuffix
            };
            area.Controllers.Add(controller);
        }

        AddViewsRecursive(item.ProjectItems, controller.ViewsFolder);
    }
}

void AddViewsRecursive(ProjectItems items, ViewsFolderInfo viewsFolder) {
  AddViewsRecursive(items, viewsFolder, false);
}

void AddViewsRecursive(ProjectItems items, ViewsFolderInfo viewsFolder, bool useNonQualifiedViewNames) {
    // Go through all the files in the subfolder to get the view names
    foreach (ProjectItem item in items) {
        if (item.Kind == Constants.vsProjectItemKindPhysicalFile) {
            if (Path.GetExtension(item.Name).Equals(".master", StringComparison.OrdinalIgnoreCase))
                continue;   // ignore master files
            viewsFolder.AddView(item, useNonQualifiedViewNames);
        }
        else if (item.Kind == Constants.vsProjectItemKindPhysicalFolder) {
            string folderName = Path.GetFileName(item.Name);
            if (folderName.Equals("App_LocalResources", StringComparison.OrdinalIgnoreCase))
                continue;
            // Use simple view names if we're already in that mode, or if the folder name is in the collection
            bool folderShouldUseNonQualifiedViewNames = useNonQualifiedViewNames || NonQualifiedViewFolders.Contains(folderName, StringComparer.OrdinalIgnoreCase);
            var subViewFolder = new ViewsFolderInfo() { Name = folderName };
            viewsFolder.SubFolders.Add(subViewFolder);
            AddViewsRecursive(item.ProjectItems, subViewFolder, folderShouldUseNonQualifiedViewNames);
        }
    }
}

void RenderControllerViews(ControllerInfo controller) {
    PushIndent("            ");
    RenderViewsRecursive(controller.ViewsFolder, controller);
    PopIndent();
}

void RenderViewsRecursive(ViewsFolderInfo viewsFolder, ControllerInfo controller) {

    // For each view, generate a readonly string
    foreach (var viewPair in viewsFolder.Views) {
        //### START_VBNET_PORT_CHANGED ###
		WriteLine("Public ReadOnly [" + EscapeID(Sanitize(viewPair.Key)) + "] As String = \"" + viewPair.Value + "\"");
    	//### END_VBNET_PORT_CHANGED ### 
	}

    // For each sub folder, generate a class and recurse
    foreach (var subFolder in viewsFolder.SubFolders) {
        string newClassName = Sanitize(subFolder.Name);#>
Shared ReadOnly s_<#=newClassName#> As _<#=newClassName#> = New _<#=newClassName#>()
Public ReadOnly Property <#=EscapeID(newClassName)#> As _<#=newClassName#> 
	Get
		Return s_<#=newClassName#>
	End Get
End Property

Public Partial Class _<#=newClassName#>
<#+
PushIndent("    ");
RenderViewsRecursive(subFolder, controller);
PopIndent();

WriteLine("End Class");
    }
}

void ProcessStaticFiles(Project project, string folder) {

    ProjectItem folderProjectItem = GetProjectItem(project, folder);
    if (folderProjectItem != null) {
        ProcessStaticFilesRecursive(folderProjectItem, "~");
    }
}

void ProcessStaticFilesRecursive(ProjectItem projectItem, string path) {

    if (IsFolder(projectItem)) { #>
    <CompilerGenerated(), DebuggerNonUserCode()> _
    Public Class <#=EscapeID(Sanitize(projectItem.Name)) #> 
        Private Const URLPATH As String = "<#=path#>/<#=projectItem.Name#>"
		
		Private Sub New()
            ' Prevent direct instantiation
        End Sub                                

		Public Shared Function Url() As String
			Return T4MVCHelpers.ProcessVirtualPath(URLPATH)
		End Function

		Public Shared Function Url(ByVal fileName As String) As String
			Return T4MVCHelpers.ProcessVirtualPath(URLPATH & "/" & fileName)
		End Function
<#+
PushIndent("    ");

// Recurse into all the items in the folder
foreach (ProjectItem item in projectItem.ProjectItems) {
    ProcessStaticFilesRecursive(item, path + "/" + projectItem.Name);
}

PopIndent();
#>
    End Class

<#+
}
    else { #>
<#+
if (!ExcludedStaticFileExtensions.Any(extension => projectItem.Name.EndsWith(extension, StringComparison.OrdinalIgnoreCase))) {
    // if it's a non-minified javascript file
    if (projectItem.Name.EndsWith(".js") && !projectItem.Name.EndsWith(".min.js")) { 
        if (AddTimestampToStaticLinks) { #>
    Public ReadOnly <#=Sanitize(projectItem.Name)#> As String = If(T4MVCHelpers.IsProduction() AndAlso T4Extensions.FileExists(URLPATH & "/<#=projectItem.Name.Replace(".js", ".min.js")#>") , Url("<#=projectItem.Name.Replace(".js", ".min.js")#>")&"?"&T4Extensions.TimestampString(URLPATH & "/<#=projectItem.Name#>") , Url("<#=projectItem.Name#>")&"?"&T4Extensions.TimestampString(URLPATH & "/<#=projectItem.Name#>"))
        <#+} else {#>
    Public ReadOnly <#=Sanitize(projectItem.Name)#> As String = If(T4MVCHelpers.IsProduction() AndAlso T4Extensions.FileExists(URLPATH & "/<#=projectItem.Name.Replace(".js", ".min.js")#>") , Url("<#=projectItem.Name.Replace(".js", ".min.js")#>") , Url("<#=projectItem.Name#>"))
        <#+}  #>          
<#+}
    else if (AddTimestampToStaticLinks) { #>
    Public ReadOnly <#=Sanitize(projectItem.Name)#> As String = Url("<#=projectItem.Name#>")&"?"&T4Extensions.TimestampString(URLPATH + "/<#=projectItem.Name#>")
<#+}
    else { #>
    Public ReadOnly <#=Sanitize(projectItem.Name)#> As String = Url("<#=projectItem.Name#>")
<#+}
} #>
<#+
// ### END_VBNET_PORT_CHANGED ###

// Non folder items may also have children (virtual folders, Class.cs -> Class.Designer.cs, template output)
// Just register them on the same path as their parent item
foreach (ProjectItem item in projectItem.ProjectItems) {
    ProcessStaticFilesRecursive(item, path);
}
    }
}
ProjectItem GetProjectItem(Project project, string name) {
    return GetProjectItem(project.ProjectItems, name);
}

ProjectItem GetProjectItem(ProjectItems items, string subPath) {

    ProjectItem current = null;
    foreach (string name in subPath.Split('\\')) {
        try {
            // ProjectItems.Item() throws when it doesn't exist, so catch the exception
            // to return null instead.
            current = items.Item(name);
        }
        catch {
            // If any chunk couldn't be found, fail
            return null;
        }
        items = current.ProjectItems;
    }

    return current;
}

static string GetVirtualPath(ProjectItem item) {
    string fileFullPath = item.get_FileNames(0);
    if (!fileFullPath.StartsWith(AppRoot, StringComparison.OrdinalIgnoreCase))
        throw new Exception(string.Format("File {0} is not under app root {1}. Please report issue.", fileFullPath, AppRoot));

    // Make a virtual path from the physical path
    return "~/" + fileFullPath.Substring(AppRoot.Length).Replace('\\', '/');
}

static string ProcessAreaOrControllerName(string name) {
    return UseLowercaseRoutes ? name.ToLowerInvariant() : name;
}

// Return all the CodeFunction2 in the CodeElements collection
static IEnumerable<CodeFunction2> GetMethods(CodeClass2 codeClass) {
    // Only look at regular method (e.g. ignore things like contructors)
    return codeClass.Members.OfType<CodeFunction2>()
        .Where(f => f.FunctionKind == vsCMFunction.vsCMFunctionFunction);
}

// Check if the class has any explicit constructor
static bool HasExplicitConstructor(CodeClass2 codeClass) {
    return codeClass.Members.OfType<CodeFunction2>().Any(
        f => f.FunctionKind == vsCMFunction.vsCMFunctionConstructor);
}

// Check if the class has a default (i.e. no params) constructor
static bool HasExplicitDefaultConstructor(CodeClass2 codeClass) {
    return codeClass.Members.OfType<CodeFunction2>().Any(
        f => f.FunctionKind == vsCMFunction.vsCMFunctionConstructor && f.Parameters.Count == 0);
}

// Find a method with a given name
static CodeFunction2 GetMethod(CodeClass2 codeClass, string name) {
    return GetMethods(codeClass).FirstOrDefault(f => f.Name == name);
}

// Find an attribute of a given type on an attribute collection
static CodeAttribute2 GetAttribute(CodeElements attributes, string attributeType) {
    for (int i = 1; i <= attributes.Count; i++) {
        var attrib = (CodeAttribute2)attributes.Item(i);
        if (attrib.FullName == attributeType) {
            return attrib;
        }
    }
    return null;
}

// Return whether a ProjectItem is a folder and not a file
static bool IsFolder(ProjectItem item) {
    return (item.Kind == Constants.vsProjectItemKindPhysicalFolder);
}

static string MakeClassName(string ns, string classname) {
    return String.IsNullOrEmpty(ns) ? classname :
        String.IsNullOrEmpty(classname) ? ns : ns + "." + codeProvider.CreateEscapedIdentifier(classname);
}

static string Sanitize(string token) {
    // Replace all invalid chars by underscores
    token = Regex.Replace(token, @"[\W\b]", "_", RegexOptions.IgnoreCase);

    // If it starts with a digit, prefix it with an underscore
    token = Regex.Replace(token, @"^\d", @"_$0");

    // Check for reserved words
    // TODO: Clean this up and add other reserved words (keywords, etc)
    if (token == "Url") token = "_Url";

    return token;
}

static string EscapeID(string id) {
    return codeProvider.CreateEscapedIdentifier(id);
}

// Data structure to collect data about an area
class AreaInfo {
    public AreaInfo() {
        Controllers = new HashSet<ControllerInfo>();
    }

    public string Name { get; set; }
    public HashSet<ControllerInfo> Controllers { get; set; }

    public string Namespace {
        get {
            // When *not* using an 'Areas' token, we need to disambiguate conflicts
            // between Area names and controller names (from the default Area)
            if (!IncludeAreasToken && DefaultArea.Controllers.Any(c => c.Name == Name))
                return Name + "Area";

            return Name;
        }
    }

    public IEnumerable<ControllerInfo> GetControllers() {
        return Controllers.Where(c => !c.IsAbstract);
    }

    public IEnumerable<ControllerInfo> GetAbstractControllers() {
        return Controllers.Where(c => c.IsAbstract);
    }
}

// Data structure to collect data about a controller class
class ControllerInfo {
    public ControllerInfo() {
        ActionMethods = new HashSet<ActionMethodInfo>();
        ViewsFolder = new ViewsFolderInfo();
    }

    public AreaInfo Area { get; set; }

    public string AreaName {
        get { return Area.Name ?? ""; }
    }

    public string T4MVCControllerFullName {
        get {
            string name = HelpersPrefix;
            if (!String.IsNullOrEmpty(AreaName))
                name += "." + EscapeID(Area.Namespace);
            return name + "." + Name; ;
        }
    }

    public string ViewPath {
        get {
            if (string.IsNullOrEmpty(Area.Name))
                return String.Format("~/{0}/{1}/", ViewsRootFolder, Name);
            else
                return String.Format("~/{0}/{1}/{2}/", AreasFolder, ViewsRootFolder, Name);
        }
    }

    // True when this is not a real controller, but a placeholder for views folders that don't match a controller
    public bool NotRealController { get; set; }

    public bool HasExplicitConstructor { get; set; }
    public bool HasExplicitDefaultConstructor { get; set; }
    public bool HasDefaultConstructor { get { return !HasExplicitConstructor || HasExplicitDefaultConstructor; } }
    public bool IsAbstract { get; set; }

    public bool GeneratedCodeIsUpToDate { get; set; }

    public string ClassName { get; set; }
    public string Name {
        get {
            // Trim the Controller suffix
            return ClassName.Substring(0, ClassName.Length - ControllerSuffix.Length);
        }
    }

    public string Namespace { get; set; }

    public string FullClassName {
        get {
            return MakeClassName(Namespace, ClassName);
        }
    }

    public string DerivedClassName {
        get {
            return "T4MVC_" + ClassName;
        }
    }

    public string FullDerivedClassName {
        get {
            if (NotRealController)
                return FullClassName;
            return MakeClassName(Namespace, DerivedClassName);
        }
    }

    public string GeneratedFileName {
        get {
			// ### START_VBNET_PORT_CHANGED ###
            return MakeClassName(AreaName, ClassName + ".generated.vb");
			// ### START_VBNET_PORT_CHANGED ###
        }
    }

    public string GeneratedFileFullPath {
        get {
            return Path.Combine(T4Folder, GeneratedFileName);
        }
    }

    public HashSet<ActionMethodInfo> ActionMethods { get; set; }

    IEnumerable<ActionMethodInfo> ActionMethodsWithNoParameters {
        get {
            return ActionMethods.Where(m => m.CanBeCalledWithoutParameters);
        }
    }

    public IEnumerable<ActionMethodInfo> ActionMethodsUniqueWithoutParameterlessOverload {
        get {
            return ActionMethodsWithUniqueNames.Except(ActionMethodsWithNoParameters, new ActionComparer());
        }
    }

    // Return a list of actions without duplicate names (even with multiple overloads)
    public IEnumerable<ActionMethodInfo> ActionMethodsWithUniqueNames {
        get {
            return ActionMethods.Distinct(new ActionComparer());
        }
    }

    class ActionComparer : IEqualityComparer<ActionMethodInfo> {
        public bool Equals(ActionMethodInfo x, ActionMethodInfo y) {
            return x.ActionName == y.ActionName;
        }

        public int GetHashCode(ActionMethodInfo obj) {
            return obj.ActionName.GetHashCode();
        }
    }

    public ViewsFolderInfo ViewsFolder { get; private set; }

    public override string ToString() {
        return Name;
    }

    public override bool Equals(object obj) {
        return obj != null && FullClassName == ((ControllerInfo)obj).FullClassName;
    }

    public override int GetHashCode() {
        return FullClassName.GetHashCode();
    }
}

// Info about a view folder, its views and its sub view folders
class ViewsFolderInfo {
    public ViewsFolderInfo() {
        Views = new Dictionary<string, string>();
        SubFolders = new List<ViewsFolderInfo>();
    }

    public void AddView(ProjectItem item, bool useNonQualifiedViewName) {
        string viewName = Path.GetFileName(item.Name);
        string viewFieldName = Path.GetFileNameWithoutExtension(viewName);
 
        // If the simple view name is already in use, include the extension (e.g. foo_ascx instead of just foo)
        if (Views.ContainsKey(viewFieldName))
            viewFieldName = Sanitize(viewName);
 
        Views[viewFieldName] = useNonQualifiedViewName ? Path.GetFileNameWithoutExtension(viewName) : GetVirtualPath(item);
    }

    public string Name { get; set; }
    public Dictionary<string, string> Views { get; private set; }
    public List<ViewsFolderInfo> SubFolders { get; set; }
}

// Data structure to collect data about a method
class FunctionInfo {
    protected CodeFunction2 _method;
    private string _signature;

    public FunctionInfo(CodeFunction2 method) {
        Parameters = new List<MethodParamInfo>();

        // Can be null when an custom ActionResult has no ctor
        if (method == null)
            return;

        _method = method;

        // Build a unique signature for the method, used to avoid duplication
        _signature = method.Name;

        CanBeCalledWithoutParameters = true;

        // Process all the parameters
        foreach (var p in method.Parameters.OfType<CodeParameter2>()) {
            // If any param is not optional, then the method can't be called without parameters
            if (p.ParameterKind != vsCMParameterKind.vsCMParameterKindOptional) {
                CanBeCalledWithoutParameters = false;
            }

            string routeNameExpression = "\"" + p.Name + "\"";

            // If there is a [Bind(Prefix = "someName")] attribute, use it
            if (p.InfoLocation != vsCMInfoLocation.vsCMInfoLocationExternal) {
                var attrib = GetAttribute(p.Attributes, "System.Web.Mvc.BindAttribute");
                if (attrib != null) {
                    var arg = attrib.Arguments.OfType<CodeAttributeArgument>().FirstOrDefault(a => a.Name == "Prefix");
                    if (arg != null)
                        routeNameExpression = arg.Value;
                }
            }
            
            Parameters.Add(
                new MethodParamInfo() {
                    Name = p.Name,
                    RouteNameExpression = routeNameExpression,
                    Type = p.Type.AsString
                });
            _signature += "," + p.Type.AsString;
        }
    }

    public string Name { get { return _method.Name; } }
    public string ReturnType { get { return _method.Type.CodeType.Name; } }
    public string ReturnTypeFullName { get { return _method.Type.CodeType.FullName; } }
    public bool IsPublic { get { return _method.Access == vsCMAccess.vsCMAccessPublic; } }
    public List<MethodParamInfo> Parameters { get; private set; }
    public bool CanBeCalledWithoutParameters { get; private set; }


    // Write out all the parameters as part of a method declaration
    public void WriteFormalParameters(bool first) {
        foreach (var p in Parameters) {
            if (first)
                first = false;
            else
                TT.Write(", ");
			// ### START_VBNET_PORT_CHANGED ###
            TT.Write("ByVal " + p.Name + " As " + p.Type);
			// ### END_VBNET_PORT_CHANGED ###
        }
    }

    // Pass non-empty param values to make sure the ActionResult ctors don't complain
    // REVIEW: this is a bit dirty
    public void WriteNonEmptyParameterValues(bool first) {
        foreach (var p in Parameters) {
            if (first)
                first = false;
            else
                TT.Write(", ");

            switch (p.Type) {
                case "string":
                    TT.Write("\" \"");
                    break;
                case "byte[]":
                    TT.Write("new byte[0]");
                    break;
                default:
                    TT.Write("default(" + p.Type + ")");
                    break;
            }
        }
    }

    public override bool Equals(object obj) {
        return obj != null && _signature == ((FunctionInfo)obj)._signature;
    }

    public override int GetHashCode() {
        return _signature.GetHashCode();
    }
}

// Data structure to collect data about an action method
class ActionMethodInfo : FunctionInfo {
    public ActionMethodInfo(CodeFunction2 method)
        : base(method) {
        // Normally, the action name is the method name. But if there is an [ActionName] on
        // the method, get the expression from that instead
        ActionNameValueExpression = '"' + Name + '"';
        var attrib = GetAttribute(method.Attributes, "System.Web.Mvc.ActionNameAttribute");
        if (attrib != null) {
            var arg = (CodeAttributeArgument)attrib.Arguments.Item(1);
            ActionNameValueExpression = arg.Value;
        }
    }

    public string ActionName { get { return Name; } }
    public string ActionNameValueExpression { get; set; }
}

// Data about an ActionResult derived type
class ResultTypeInfo {
    CodeType _codeType;
    public ResultTypeInfo(CodeType codeType) {
        _codeType = codeType;

        var ctor = _codeType.Members.OfType<CodeFunction2>().FirstOrDefault(
            f => f.FunctionKind == vsCMFunction.vsCMFunctionConstructor);
        Constructor = new FunctionInfo(ctor);
    }

    public string Name { get { return _codeType.Name; } }
    public string FullName { get { return _codeType.FullName; } }
    public FunctionInfo Constructor { get; set; }
    public IEnumerable<FunctionInfo> AbstractMethods {
        get {
            return _codeType.Members.OfType<CodeFunction2>().Where(
                f => f.MustImplement).Select(f => new FunctionInfo(f));
        }
    }
}

class MethodParamInfo {
    public string Name { get; set; }
    public string RouteNameExpression { get; set; }
    public string Type { get; set; }
}


/*
    Manager.tt from Damien Guard: http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
*/


// Manager class records the various blocks so it can split them up
class Manager {
    private class Block {
        public String Name;
        public int Start, Length;
    }

    private Block currentBlock;
    private List<Block> files = new List<Block>();
    private Block footer = new Block();
    private Block header = new Block();
    private ITextTemplatingEngineHost host;
    private StringBuilder template;
    protected List<String> generatedFileNames = new List<String>();

    public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template) {
        return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
    }

    public void KeepGeneratedFile(String name) {
        name = Path.Combine(Path.GetDirectoryName(host.TemplateFile), name);
        generatedFileNames.Add(name);
    }
    
    public void StartNewFile(String name) {
        if (name == null)
            throw new ArgumentNullException("name");
        CurrentBlock = new Block { Name = name };
    }

    public void StartFooter() {
        CurrentBlock = footer;
    }

    public void StartHeader() {
        CurrentBlock = header;
    }

    public void EndBlock() {
        if (CurrentBlock == null)
            return;
        CurrentBlock.Length = template.Length - CurrentBlock.Start;
        if (CurrentBlock != header && CurrentBlock != footer)
            files.Add(CurrentBlock);
        currentBlock = null;
    }

    public virtual void Process(bool split) {
        if (split) {
            EndBlock();
            String headerText = template.ToString(header.Start, header.Length);
            String footerText = template.ToString(footer.Start, footer.Length);
            String outputPath = Path.GetDirectoryName(host.TemplateFile);
            files.Reverse();
            foreach (Block block in files) {
                String fileName = Path.Combine(outputPath, block.Name);
                String content = headerText + template.ToString(block.Start, block.Length) + footerText;
                generatedFileNames.Add(fileName);
                CreateFile(fileName, content);
                template.Remove(block.Start, block.Length);
            }
        }
    }

    protected virtual void CreateFile(String fileName, String content) {
        if (IsFileContentDifferent(fileName, content))
            File.WriteAllText(fileName, content);
    }

    public virtual String GetCustomToolNamespace(String fileName) {
        return null;
    }

    public virtual String DefaultProjectNamespace {
        get { return null; }
    }

    protected bool IsFileContentDifferent(String fileName, String newContent) {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }

    private Manager(ITextTemplatingEngineHost host, StringBuilder template) {
        this.host = host;
        this.template = template;
    }

    private Block CurrentBlock {
        get { return currentBlock; }
        set {
            if (CurrentBlock != null)
                EndBlock();
            if (value != null)
                value.Start = template.Length;
            currentBlock = value;
        }
    }

    private class VSManager : Manager {
        private EnvDTE.ProjectItem templateProjectItem;
        private EnvDTE.DTE dte;
        private Action<String> checkOutAction;
        private Action<IEnumerable<String>> projectSyncAction;

        public override String DefaultProjectNamespace {
            get {
                return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
            }
        }

        public override String GetCustomToolNamespace(string fileName) {
            return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
        }

        public override void Process(bool split) {
            if (templateProjectItem.ProjectItems == null)
                return;
            base.Process(split);
            projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
        }

        protected override void CreateFile(String fileName, String content) {
            if (IsFileContentDifferent(fileName, content)) {
                CheckoutFileIfRequired(fileName);
                File.WriteAllText(fileName, content);
            }
        }

        internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
            : base(host, template) {
            var hostServiceProvider = (IServiceProvider)host;
            if (hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
            dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
            if (dte == null)
                throw new ArgumentNullException("Could not obtain DTE from host");
            templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
            checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
            projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
        }

        private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames) {
            var keepFileNameSet = new HashSet<String>(keepFileNames);
            var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
            var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
            foreach (EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                projectFiles.Add(projectItem.get_FileNames(0), projectItem);

            // Remove unused items from the project
            foreach (var pair in projectFiles)
                if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                    pair.Value.Delete();

            // Add missing files to the project
            foreach (String fileName in keepFileNameSet)
                if (!projectFiles.ContainsKey(fileName))
                    templateProjectItem.ProjectItems.AddFromFile(fileName);
        }

        private void CheckoutFileIfRequired(String fileName) {
            var sc = dte.SourceControl;
            if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
                checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
        }
    }
}

/*
    End of Manager.tt
*/
#>
